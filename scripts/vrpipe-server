#!/usr/bin/env perl
use strict;
use warnings;

use EV;
use AnyEvent;
use VRPipe::Interface::CmdLine;
use VRPipe::Interface::BackEnd;

# handle options
my $cmdline = VRPipe::Interface::CmdLine->new(description => "Control the VRPipe server, which provides the web and cmdline interfaces, the local scheduler, and keeps the pipeline system itself running.",
                                              extra_args  => 'start|stop|restart|status',
                                              opt_spec    => [['foreground|f', 'Do not daemonize - the server will run in the foreground, logging to STDERR']]);
my $backend;
my $deployment = $cmdline->opts('deployment');
my $foreground = $cmdline->opts('foreground');

my $command = shift;
unless ($command) {
    $cmdline->error("a command is required");
    $cmdline->help;
}

# act on the given command
my $status = $cmdline->check_server(1);
my (undef, $port, $url) = @{ $cmdline->_ua_port_baseurl };
my $exit = 0;
if ($command eq 'status') {
    if ($status == 1) {
        $cmdline->output("Server is running at $url");
    }
    elsif ($status == 0) {
        $cmdline->output("Server is not running");
    }
    elsif ($status == -1) {
        $cmdline->output("A server is listening on port $port, but is not responding correctly");
    }
}
elsif ($command eq 'stop') {
    my $stopped = stop();
    $exit = !$stopped;
}
elsif ($command eq 'start') {
    my $started = start();
    $exit = !$started;
}
elsif ($command eq 'restart') {
    $cmdline->output("Restarting server...");
    my $stopped = stop();
    my $started = 0;
    if ($stopped) {
        my $started = start();
    }
    $exit = !$started;
}
else {
    $cmdline->die_with_error("$command is an invalid command");
}

exit $exit;

sub stop {
    if ($status == 1) {
        my $response = $cmdline->server_get('/stop');
        if ($response eq 'Stopping server') {
            # the server responded that it would stop; give it up to 5 seconds
            # to actually do that
            my $seconds = 5;
            while ($seconds--) {
                $status = $cmdline->check_server(1);
                last if $status == 0;
                sleep(1);
            }
            
            if ($status == 0) {
                $cmdline->output("Server was stopped");
                return 1;
            }
            else {
                $cmdline->output("Server claimed it would stop, but it still seems to be running");
                return 0;
            }
        }
        else {
            $cmdline->output("Failed to stop server (it responded: '$response')");
            return 0;
        }
    }
    elsif ($status == 0) {
        $cmdline->output("Server was not running");
        return 1;
    }
    elsif ($status == -1) {
        $cmdline->output("Will not attempt to stop the server listening on port $port, since it does not seem to be ours");
        return 0;
    }
}

sub start {
    if ($status == 1) {
        $cmdline->output("Server is already running");
        return 1;
    }
    elsif ($status == 0) {
        $cmdline->output("Will start server at $url");
        start_server();
    }
    elsif ($status == -1) {
        $cmdline->output("Will not attempt to start, since another incompatible server is already listening on port $port");
        return 0;
    }
}

sub start_server {
    # initialize the VRPipe backend
    $backend = VRPipe::Interface::BackEnd->new(deployment => $deployment);
    
    # daemonize unless we're not supposed to
    my $orig_dir = $backend->daemonize unless $foreground;
    
    # setup the signals we'll react to
    $SIG{HUP}  = 'IGNORE';
    $SIG{PIPE} = 'IGNORE';
    my $sigterm_watcher = EV::signal 'TERM', sub { shutdown_server("SIGTERM received"); };
    my $sigint_watcher  = EV::signal 'INT',  sub { shutdown_server("SIGINT received"); };
    my $sigquit_watcher = EV::signal 'QUIT', sub { shutdown_server("SIGQUIT received"); };
    
    # setup the http page requests we'll respond to
    my $httpd = $backend->httpd;
    $httpd->reg_cb(
        '/' => sub {
            my ($httpd, $req) = @_;
            
            $req->respond({ content => ['text/html', "<html><body><h1>VRPipe Homepage</h1>" . q[<p>Complete web interface to VRPipe coming soon; currently you can just look at the <a href="/status?brief=1&amp;incomplete=1">status</a> page (like the vrpipe-status command line script).</p>] . "</body></html>"] });
        },
        '/status' => sub { $backend->handle_httpd_event(\&status, @_); },
        '/dsn'    => sub {
            my ($httpd, $req) = @_;
            $req->respond({ content => ['text/plain', $backend->dsn] });
        },
        '/stop' => sub {
            my ($httpd, $req) = @_;
            
            $req->respond({ content => ['text/plain', 'Stopping server'] });
            shutdown_server("Received the stop command");
        },
        '' => sub {
            my ($httpd, $req) = @_;
            $req->respond([404, 'not found', { 'Content-Type' => 'text/plain' }, '404: requested page (' . $req->url . ') is not valid']);
        });
    
    # run the event loop
    $backend->log("The $deployment server at $url for VRPipe database " . $backend->dsn . " has started.");
    EV::run;
    
    $backend->log("The $deployment server at $url for VRPipe database " . $backend->dsn . " is exiting!");
    exit 0;
}

sub shutdown_server {
    my $msg = shift;
    $backend->log($msg . ", will gracefully shut down server.");
    EV::unloop;
}

# "page" subs
sub status {
    my $req = shift;
    
    my $opts = $backend->req_to_opts($req, ['setup!PipelineSetup']);
    $opts->{'_multiple_setups'} = 1;
    my $list            = $opts->{list};
    my $incomplete_only = $opts->{incomplete};
    my $brief           = $opts->{brief};
    
    my $xml = '<title>Current status of PipelineSetups</title>';
    
    # $xml .= '<options><bool></bool></options>';
    
    my @setups = $backend->get_pipelinesetups($opts);
    if (@setups) {
        my @objects;
        foreach my $setup (@setups) {
            my $object;
            foreach my $attr (qw(id name user active)) {
                $object .= qq{<attribute name="$attr"><![CDATA[} . $setup->$attr() . ']]></attribute>';
            }
            
            if ($list) {
                push(@objects, $object);
                next;
            }
            
            my $datasource = $setup->datasource;
            my $num_elements;
            my $incomplete_pager;
            eval {
                $num_elements = VRPipe::DataElement->search({ datasource => $datasource->id, withdrawn => 0 });
                $incomplete_pager = $datasource->incomplete_element_states($setup, 0);
            };
            my $ds_error = $@;
            if ($ds_error || !$incomplete_pager) {
                $ds_error ||= 'Could not create an incomplete_element_states pager for setup ' . $setup->id;
                $object .= q{<attribute name="problems"><![CDATA[} . "There is a problem with the DataSource for this pipeline, so no more information can be retrieved about it.\n$ds_error\n" . ']]></attribute>';
                push(@objects, $object);
                next;
            }
            
            my $num_incomplete = $incomplete_pager->total_entries;
            next if $incomplete_only && !$num_incomplete;
            
            my $pipeline     = $setup->pipeline;
            my $step_members = $pipeline->step_members;
            unless ($brief) {
                # pipeline details
                $object .= '<attribute name="pipeline"><object class="Pipeline" display_mode="full">';
                foreach my $attr (qw(id name description)) {
                    $object .= qq{<attribute name="$attr"><![CDATA[} . $pipeline->$attr() . ']]></attribute>';
                }
                $object .= '<attribute name="num_steps"><![CDATA[' . $step_members . ']]></attribute>';
                $object .= '</object></attribute>';
                
                # setup options and output root
                my $ps_opts = $setup->options;
                $object .= '<attribute name="options">';
                if (keys %$ps_opts) {
                    $object .= $backend->hash_to_xml($ps_opts);
                }
                else {
                    $object .= '<![CDATA[(used with default/no options)]]>';
                }
                $object .= '</attribute>';
                $object .= '<attribute name="output_root"><![CDATA[' . $setup->output_root . ']]></attribute>';
                
                # datasource details
                $object .= '<attribute name="datasource"><object class="DataSource" display_mode="full">';
                foreach my $attr (qw(id type method source)) {
                    $object .= qq{<attribute name="$attr"><![CDATA[} . $datasource->$attr() . ']]></attribute>';
                }
                my $ds_opts = $datasource->options;
                $object .= '<attribute name="options">';
                if (keys %$ds_opts) {
                    $object .= $backend->hash_to_xml($ds_opts);
                }
                else {
                    $object .= '<![CDATA[(used with default/no options)]]>';
                }
                $object .= '</attribute>';
                $object .= '</object></attribute>';
            }
            
            $object .= '<attribute name="elements_total"><![CDATA[' . $num_elements . ']]></attribute>';
            $object .= '<attribute name="elements_incomplete"><![CDATA[' . $num_incomplete . ']]></attribute>';
            if ($num_incomplete) {
                my %status_hash;
                my $fully_complete = $num_elements - $num_incomplete;
                $status_hash{$step_members} = $fully_complete;
                my $num_steps_complete = $fully_complete * $step_members;
                while (my $incompletes = $incomplete_pager->next) {
                    foreach my $es (@$incompletes) {
                        my $completed_steps = $es->completed_steps;
                        $num_steps_complete += $completed_steps;
                        $status_hash{$completed_steps}++;
                    }
                }
                $object .= '<attribute name="steps_completed">' . $backend->hash_to_xml(\%status_hash, [sort { my ($ay) = $a =~ /^(\d+)/; my ($be) = $b =~ /^(\d+)/; $ay <=> $be } keys %status_hash]) . '</attribute>';
                
                my $steps_to_complete = $num_elements * $step_members;
                my $percent_complete = sprintf("%0.2f", (100 / $steps_to_complete) * $num_steps_complete);
                $object .= '<attribute name="completion" explanation="' . "Pipeline currently $percent_complete\% complete ($num_steps_complete / $steps_to_complete steps completed)" . '"><![CDATA[' . "$percent_complete\%" . ']]></attribute>';
                
                my $pager = VRPipe::Submission->search_paged({ "_done" => 0, 'stepstate.pipelinesetup' => $setup->id }, { join => ['stepstate'], prefetch => 'job' });
                
                my %sub_stats;
                while (my $subs = $pager->next) {
                    foreach my $sub (@$subs) {
                        my $sub_state = $sub->done ? 'done' : ($sub->failed ? 'failed' : 'scheduled');
                        if ($sub_state eq 'scheduled') {
                            my $job = $sub->job;
                            $sub_state = $job->finished ? 'processing' : ($job->running ? 'running' : 'pending');
                        }
                        $sub_stats{$sub_state}++;
                    }
                }
                if (keys %sub_stats) {
                    $object .= '<attribute name="submission_state">' . $backend->hash_to_xml(\%sub_stats, [qw(running processing pending failed)]) . '</attribute>';
                    if (keys %sub_stats == 1 && exists $sub_stats{failed}) {
                        my $failed = $sub_stats{failed};
                        if ($failed >= $num_incomplete) {
                            $object .= q{<attribute name="problems"><![CDATA[} . "WARNING! It looks like this setup may be STALLED due to repeated failures.\nInvestigate using: vrpipe-submissions --setup " . $setup->id . " --failed" . ']]></attribute>';
                        }
                    }
                }
            }
            else {
                if ($num_elements == 0) {
                    $object .= '<attribute name="completion" explanation="Pipeline has no inputs to work on (yet?), so has done nothing."><![CDATA[n/a]]></attribute>';
                }
                else {
                    $object .= '<attribute name="completion" explanation="Pipeline currently 100% complete!"><![CDATA[100%]]></attribute>';
                }
            }
            
            push(@objects, $object);
        }
        
        if (@objects) {
            my $mode = $list ? 'list' : ($brief ? 'brief' : 'full');
            $xml .= '<objects>' . join('', map { qq[<object class="PipelineSetup" display_mode="$mode">] . $_ . '</object>' } @objects) . '</objects>';
        }
    }
    
    return $xml;
}
