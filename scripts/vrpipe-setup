#!/usr/bin/env perl
use strict;
use warnings;

use VRPipe::Persistent::SchemaBase;

use Getopt::Long;

my $help = 0;
my $deployment = 'production';
my ($desired_setup, $override_reqs, $list);
GetOptions("help" => \$help,
           "deployment=s" => \$deployment,
           "setup=s" => \$desired_setup,
           "requirements" => \$override_reqs,
           "list" => \$list);

if ($deployment !~ /^(?:testing|production)$/) {
    warn "--deployment must be testing|production\n";
    $help = 1;
}

if ($desired_setup && $list) {
    warn "--setup and --list don't make sense together; ignoring --list\n";
    $list = 0;
}

if ($help) {
    print <<HELP;
Setup a new pipeline, or alter the configuration of an existing one:
vrpipe-status [options]

Options:
    --deployment <testing|production> (default production) Create/change
                                      pipelinesetups in your testing or
                                      production database
    --setup <int|string>  Change the given pipeline setup (by id or name)
    --requirments         When changing an existing setup, be given the option
                          to override step resource requirments (eg. memory
                          needed)
    --list                Just list out the setup names and ids, so you can
                          subsequently run this using --setup

HELP
    exit;
}

VRPipe::Persistent::SchemaBase->database_deployment($deployment);
require VRPipe::Persistent::Schema;

my $setup;
my $m = VRPipe::Manager->get;
if ($desired_setup) {
    my $schema = $m->result_source->schema;
    if ($desired_setup =~ /^\d+$/) {
        $setup = $schema->resultset("PipelineSetup")->find({ id => $desired_setup });
        unless ($setup) {
            die "$desired_setup is not a valid pipeline setup id\n";
        }
    }
    else {
        $setup = $schema->resultset("PipelineSetup")->find({ name => $desired_setup });
        unless ($setup) {
            die "$desired_setup is not a valid pipeline setup name\n";
        }
    }
}

if ($setup) {
    # allow the user to change pipeline setup options
    print "Pipeline Setup '", $setup->name, "' (id ", $setup->id, ") currently has these options:\n";
    
    # Get a list of all options possible, without duplication
    my %option_names;
    my $option_num = 0;
    my @options;
    foreach my $stepm ($setup->pipeline->step_members) {
        my $step = $stepm->step;
        my $option_defs = $step->options_definition;
        foreach my $key (sort keys %$option_defs) {
            next if exists $option_names{$key};
            $option_num++;
            $option_names{$key} = $option_num;
            
            my $step_option = $option_defs->{$key};
            $options[$option_num] = [$key, $step_option->description, $step_option->optional, $step_option->default_value, $step_option->allowed_values];
        }
        
        if ($override_reqs) {
            # also give the generic memory/time etc. options user could set for this
            # step
            my $step_name = $step->name;
            foreach my $resource (qw(memory time cpus tmp_space)) { # local_space custom
                my $key = $step_name.'_'.$resource;
                next if exists $option_names{$key};
                $option_num++;
                $option_names{$key} = $option_num;
                $options[$option_num] = [$key, "Override the $resource requirement for the step '$step_name'", 1, '', []];
            }
        }
    }
    
    # Show the user the list, along with currently set options, allow them to
    # change an option, then repeat until they choose to finish
    while (1) {
        my $current_opts = $setup->options;
        foreach my $i (1..$option_num) {
            my ($key, $desc, $optional, $default, $allowed) = @{$options[$i]};
            my $current = defined $current_opts->{$key} ? $current_opts->{$key} : '[not set]';
            my $comment = $optional ? 'optional' : 'REQUIRED';
            print "$i. $key ($comment) => $current\n";
            print "\tDescription: $desc\n";
            if ($default) {
                print "\tDefault: $default\n";
            }
            if (@$allowed) {
                print "\tAllowed values: ", join(' | ', @$allowed), "\n";
            }
        }
        
        my $choice = pick_number("Choose an option to change", $option_num);
        my $chosen_key = $options[$choice]->[0];
        print STDERR "Provide a new value for '$chosen_key': ";
        my $val = <>;
        chomp($val);
        $current_opts->{$chosen_key} = $val;
        $setup->options($current_opts);
        $setup->update;
        print "Option updated!\n\n";
        
        print STDERR "Do you want to change another option? [y/n] n: ";
        my $answer = <>;
        chomp($answer);
        last unless $answer eq 'y';
        print "\n";
    }
    
    # (probably not a good idea to allow changing datasource options?...)
}
elsif ($list) {
    # list existing setups
    system("vrpipe-status --deployment $deployment --list"); #*** bleugh...
}
else {
    # allow the user to create a new setup
    die "Creating new setups is not yet implemented\n";
}

exit;

sub pick_number {
    my ($question, $max) = @_;
    
    print STDERR "\n$question: ";
    
    my $answer;
    do {
        $answer = <>;
        chomp($answer);
        
        unless (defined $answer && $answer =~ /^\d+$/ && $answer >= 1 && $answer <= $max) {
            undef $answer;
            warn "Your answer must be a number between 1 and $max\n";
            print STDERR "\n$question: ";
        }
    }
    while (! defined $answer);
    
    return $answer;
}
