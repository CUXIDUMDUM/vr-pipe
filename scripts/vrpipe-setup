#!/usr/bin/env perl
use strict;
use warnings;

use VRPipe::Persistent::SchemaBase;
use Module::Find;

use Getopt::Long;

my $help = 0;
my $deployment = 'production';
my $user = getlogin || getpwuid($<);
my ($desired_setup, $override_reqs, $deactivate, $reactivate, $list);
GetOptions("help" => \$help,
           "deployment=s" => \$deployment,
           "setup=s" => \$desired_setup,
           "requirements" => \$override_reqs,
           "deactivate" => \$deactivate,
           "reactivate" => \$reactivate,
           "list" => \$list,
           "user=s" => \$user);

if ($deployment !~ /^(?:testing|production)$/) {
    warn "--deployment must be testing|production\n";
    $help = 1;
}

if ($desired_setup && $list) {
    warn "--setup and --list don't make sense together; ignoring --list\n";
    $list = 0;
}

if ($user eq 'all' && ! $list) {
    warn "--user all when not listing with --list don't make sense; when creating a new setup set a real user name with --user, or leave it to the default\n";
    $help = 1;
}

if (($override_reqs || $deactivate || $reactivate) && ! $desired_setup) {
    warn "--requirments, --deactivate and --activate only make sense when given a --setup; ignoring them\n";
    undef $override_reqs;
    undef $deactivate;
    undef $reactivate;
}

if ($deactivate && $reactivate) {
    warn "--deactivate and --activate are mutually exclusive; ignoring them both\n";
    undef $deactivate;
    undef $reactivate;
}

if ($help) {
    print <<HELP;
Setup a new pipeline, or alter the configuration of an existing one:
vrpipe-setup [options]

Options:
    --deployment <testing|production> (default production) Create/change
                                      pipelinesetups in your testing or
                                      production database
    --setup <int|string>  Change the given pipeline setup (by id or name)
    --requirments         When changing an existing setup, be given the option
                          to override step resource requirments (eg. memory
                          needed)
    --deactivate          Turn off the given --setup
    --reactivate          Turn on the given --setup
    --list                Just list out the setup names and ids, so you can
                          subsequently run this using --setup
    --user                When listing setups, only list those created by this
                          user. When creating a setup, create for this user
                          (defaults to your current username, specify 'all' to
                          see setups from all users)

HELP
    exit;
}

VRPipe::Persistent::SchemaBase->database_deployment($deployment);
require VRPipe::Persistent::Schema;

my $setup;
my $m = VRPipe::Manager->get;
my $schema = $m->result_source->schema;

if ($desired_setup) {
    if ($desired_setup =~ /^\d+$/) {
        $setup = $schema->resultset("PipelineSetup")->find({ id => $desired_setup });
        unless ($setup) {
            die "$desired_setup is not a valid pipeline setup id\n";
        }
    }
    else {
        $setup = $schema->resultset("PipelineSetup")->find({ name => $desired_setup });
        unless ($setup) {
            die "$desired_setup is not a valid pipeline setup name\n";
        }
    }
}

if ($setup) {
    # are we de/reactivating it?
    if ($deactivate || $reactivate) {
        if ($deactivate) {
            $setup->active(0);
        }
        elsif ($reactivate) {
            $setup->active(1);
        }
        $setup->update;
        
        my $active = $setup->active;
        
        print "The 'active' state of Pipeline Setup '", $setup->name, "' (id ", $setup->id, ") is now $active\n";
    }
    else {
        # allow the user to change pipeline setup options
        print "Pipeline Setup '", $setup->name, "' (id ", $setup->id, ") currently has these options:\n";
        
        # Get a list of all options possible, without duplication
        my %option_names;
        my $option_num = 0;
        my @options;
        foreach my $stepm ($setup->pipeline->step_members) {
            my $step = $stepm->step;
            my $option_defs = $step->options_definition;
            foreach my $key (sort keys %$option_defs) {
                next if exists $option_names{$key};
                $option_num++;
                $option_names{$key} = $option_num;
                
                my $step_option = $option_defs->{$key};
                $options[$option_num] = [$key, $step_option->description, $step_option->optional, $step_option->default_value, $step_option->allowed_values];
            }
            
            if ($override_reqs) {
                # also give the generic memory/time etc. options user could set for this
                # step
                my $step_name = $step->name;
                foreach my $resource (qw(memory time cpus tmp_space)) { # local_space custom
                    my $key = $step_name.'_'.$resource;
                    next if exists $option_names{$key};
                    $option_num++;
                    $option_names{$key} = $option_num;
                    $options[$option_num] = [$key, "Override the $resource requirement for the step '$step_name'", 1, '', []];
                }
            }
        }
        
        # Show the user the list, along with currently set options, allow them to
        # change an option, then repeat until they choose to finish
        while (1) {
            my $current_opts = $setup->options;
            foreach my $i (1..$option_num) {
                my ($key, $desc, $optional, $default, $allowed) = @{$options[$i]};
                my $current = defined $current_opts->{$key} ? $current_opts->{$key} : '[not set]';
                my $comment = $optional ? 'optional' : 'REQUIRED';
                print "$i. $key ($comment) => $current\n";
                print "\tDescription: $desc\n";
                if ($default) {
                    print "\tDefault: $default\n";
                }
                if (@$allowed) {
                    print "\tAllowed values: ", join(' | ', @$allowed), "\n";
                }
            }
            
            my $choice = pick_number("Choose an option to change", $option_num);
            my $chosen_key = $options[$choice]->[0];
            my $val = ask_question("Provide a new value for '$chosen_key'");
            $current_opts->{$chosen_key} = $val;
            $setup->options($current_opts);
            $setup->update;
            print "Option updated!\n\n";
            
            my $answer = ask_question("Do you want to change another option?", [qw(y n)], 'n');
            last unless $answer eq 'y';
            print "\n";
        }
        
        # (probably not a good idea to allow changing datasource options?...)
    }
}
elsif ($list) {
    # list existing setups, including those that have been deactivated
    my $rs;
    if ($user eq 'all') {
        $rs = $schema->resultset("PipelineSetup");
    }
    else {
        $rs = $schema->resultset("PipelineSetup")->search( { user => $user } );
    }
    while (my $setup = $rs->next) {
        my $active = $setup->active ? 'active' : 'inactive';
        print "Pipeline Setup '", $setup->name, "' (id ", $setup->id, ", $active for user ", $setup->user, ")\n";
    }
}
else {
    # allow the user to create a new setup
    my $setup_name = ask_question("What would you like to call your new pipeline setup?", undef, undef, 1, \&already_exists, 'PipelineSetup', 'name');
    my $pipeline = ask_for_object("Pick a pipeline from the list to run", 'Pipeline', 'name');
    my @sms = $pipeline->steps;
    my @steps = map { $_->step } @sms;
    
    # find the step that whoes input is the data element
    my @adaptors = $schema->resultset('StepAdaptor')->search({ pipeline => $pipeline->id });
    my ($source_input_step_num, $source_input_step_kind);
    ADAP: foreach my $adaptor (@adaptors) {
        my $hash = $adaptor->adaptor_hash;
        while (my ($kind, $ins_hash) = each %$hash) {
            if (exists $ins_hash->{data_element}) {
                $source_input_step_num = $adaptor->to_step;
                $source_input_step_kind = $kind;
                last ADAP;
            }
        }
    }
    unless ($source_input_step_num) {
        die "Your chosen pipeline doesn't seem to accept any user input!\n";
    }
    
    # figure out what sort of input data is expected
    my ($source_input_step) = map { $_->step; } grep { $_->step_number == $source_input_step_num } @sms;
    my $source_input_io_def = $source_input_step->inputs_definition->{$source_input_step_kind};
    print "Your chosen pipeline takes DataSource input during step $source_input_step_num (", $source_input_step->name, " - ", $source_input_step->description, "), which expects:\n";
    describe_io_def($source_input_io_def);
    
    # ask the user for the DataSource details
    my @ds_types;
    my $ds_num = 0;
    print "\n";
    foreach my $ds_type (sub_modules('DataSource')) {
        $ds_num++;
        my $ds_module = "VRPipe::DataSource::$ds_type";
        eval "require $ds_module;";
        my $ds = $ds_module->new;
        print "$ds_num. $ds_type (", $ds->description, ")\n";
        $ds_types[$ds_num] = $ds_type;
    }
    my $chosen_ds_num = pick_number("Pick a DataSource type from the list", $ds_num);
    my $chosen_ds_type = $ds_types[$chosen_ds_num];
    
    # get the source
    my $ds_module = "VRPipe::DataSource::$chosen_ds_type";
    my $ds = $ds_module->new;
    print "$chosen_ds_type DataSources have a source described as:\n", $ds->source_description, "\n";
    my $ds_source = ask_question("Supply the source", undef, undef, 1);
    
    # pick a method
    print "\n";
    my $chosen_method;
    my @method_names = $ds->get_methods;
    if (@method_names == 1) {
        $chosen_method = $method_names[0];
        print "The $chosen_ds_type DataSource has only one method: $chosen_method (", $ds->method_description($chosen_method), ")\n";
    }
    else {
        my $method_num = 0;
        my @ds_methods;
        foreach my $method (@method_names) {
            $method_num++;
            print "$method_num. $method (", $ds->method_description($method), ")\n";
            $ds_methods[$method_num] = $method;
        }
        my $chosen_method_num = pick_number("Pick one of the $chosen_ds_type DataSource methods from the list", $method_num);
        $chosen_method = $ds_methods[$chosen_method_num];
    }
    
    # pick method options
    my %chosen_method_args;
    my @method_opts = $ds->method_options($chosen_method);
    if (@method_opts) {
        print "\nPlease provide your options to the '$chosen_method' method:\n";
        foreach my $method_opt (@method_opts) {
            my ($kind, $name, $req, $default, $constraint) = @$method_opt;
            next unless $kind eq 'named';
            my $comment = $req ? 'REQUIRED' : 'optional';
            my $arg = ask_question("\t$name ($comment, a $constraint)", undef, $default, $req);
            if (defined $arg && "$arg" ne '') {
                $chosen_method_args{$name} = $arg;
            }
        }
    }
    else {
        print "(the '$chosen_method' method has no options)\n";
    }
    
    # pick pipeline (step) options
    my %step_options;
    my %step_option_order;
    my $soo_i = 0;
    foreach my $step (@steps) {
        my $step_name = $step->name;
        my $def = $step->options_definition;
        while (my ($key, $vso) = each %$def) {
            unless (exists $step_options{$key}) {
                $soo_i++;
                $step_option_order{$soo_i} = $key;
            }
            
            push(@{$step_options{$key}->{steps}}, $step_name);
            # *** how do we better handle different steps having the same option
            #     key but different vsos? Ignored for now; we just use the last
            $step_options{$key}->{vso} = $vso;
        }
    }
    my %pipeline_args;
    if (keys %step_options) {
        print "\nPlease provide options for the '", $pipeline->name, "' pipeline:\n";
        foreach my $soo_i (sort { $a <=> $b } keys %step_option_order) {
            my $key = $step_option_order{$soo_i};
            my @steps = @{$step_options{$key}->{steps}};
            my $vso = $step_options{$key}->{vso};
            my $comment = $vso->optional ? 'optional' : 'REQUIRED';
            $comment .= ', used by step';
            $comment .= 's' if @steps > 1;
            my $arg = ask_question("\t$key ($comment ".join(", ", @steps).")\n\t".$vso->description, $vso->allowed_values, $vso->default_value, ! $vso->optional); #*** could vso be altered so that it could actually validate the answer right away?...
            if (defined $arg && "$arg" ne '') {
                $pipeline_args{$key} = $arg;
            }
        }
    }
    else {
        print "\n(the ", $pipeline->name, " pipeline has no options)\n";
    }
    
    # *** ask for resource requirment overrides for each step? But we don't
    #     know what defaults each step has...
    
    # output root?
    my $output_root = ask_question("Please provide the absolute path to the root directory that output files will be written to", undef, undef, 1);
    
    # confirm with the user everything is correct
    print "\nWe've now gathered all information; here's what you've asked for:\n";
    print "\tPipelineSetup name: $setup_name (for user $user)\n";
    print "\tDataSource: $chosen_ds_type\->$chosen_method with source $ds_source\n";
    while (my ($key, $val) = each %chosen_method_args) {
        print "\t\t$key => $val\n";
    }
    print "\tPipeline: ", $pipeline->name, " (outputting to $output_root)\n";
    while (my ($key, $val) = each %pipeline_args) {
        print "\t\t$key => $val\n";
    }
    my $correct = ask_question("Is all of this correct?", [qw(y n)], undef, 1);
    
    # actually create the datasource and pipelinesetup
    if ($correct eq 'y') {
        my $ds = VRPipe::DataSource->get(type => $chosen_ds_type, method => $chosen_method, source => $ds_source, options => \%chosen_method_args);
        my $ps = VRPipe::PipelineSetup->get(name => $setup_name, datasource => $ds, pipeline => $pipeline, output_root => $output_root, options => \%pipeline_args, user => $user);
        print "\nYour new PipelineSetup has been created!\nName: $setup_name; Id: ", $ps->id, " (remember at least one of these for use later)\n";
    }
    else {
        die "Abandoning the setup, nothing was done\n";
    }
}

exit;

sub describe_io_def {
    my $io_def = shift;
    
    print "\tFile type = ", $io_def->type, " (", $io_def->description, ")\n";
    my $files_comment = $io_def->check_existence ? 'and they must exist' : "and they don't have to exist yet";
    my $max = $io_def->max_files;
    if ($max == -1) {
        $max = 'unlimited';
    }
    print "\tNumber of files = ", $io_def->min_files, '..', $max, " ($files_comment)\n";
    my $metadata = $io_def->metadata;
    if (keys %$metadata) {
        print "\tFiles must also have the following metadata associated with them (so be sure to pick a DataSource capable of adding this metadata):\n";
        my %optional = map { $_ => 1 } @{delete $metadata->{optional}};
        foreach my $key (sort keys %$metadata) {
            my $val = $metadata->{$key};
            my $comment = exists $optional{$key} ? 'optional' : 'REQUIRED';
            print "\t\t$key => $val ($comment)\n";
        }
    }
}
