#!/usr/bin/env perl
use strict;
use warnings;

use VRPipe::Persistent::SchemaBase;

use Getopt::Long;
use Path::Class;
use File::Find;

my $help = 0;
my $deployment = 'production';
my @steps;
my ($desired_setup, $pretend, $verbose, $force, $recurse);
GetOptions("help" => \$help,
           "deployment=s" => \$deployment,
           "setup=s" => \$desired_setup,
           "steps=s{,}" => \@steps,
           "pretend" => \$pretend,
           "f|force" => \$force,
           "r|recursive" => \$recurse,
           "verbose" => \$verbose);

my @paths = @ARGV;

my @search_and_replace;
unless ($help) {
    if ($deployment !~ /^(?:testing|production)$/) {
        warn "--deployment must be testing|production\n";
        $help = 1;
    }
    
    if ($desired_setup || @steps) {
        unless ($desired_setup) {
            warn "--setup is required when using --steps\n";
            $help = 1;
        }
        unless (@steps) {
            warn "--steps is required when using --setup\n";
            $help = 1;
        }
    }
    
    if ($pretend) {
        $verbose = 1;
    }
}

if ($help) {
    print <<HELP;
Delete files on disk, like unix 'rm', also updating the VRPipe database. Also
let's you delete output files of particular steps in a particular pipeline.

To delete specified files, use standard unix 'rm' arguments.

To delete pipeline outputs, supply both:
    --setup <int|string>          Pipeline setup (id or name)
    --setups <step name|number>   One or more step names/numbers to choose which
                                  step outputs you want to delete. If a step
                                  outputs more than one kind of file, you can
                                  limit to just one of the kinds by saying
                                  something like --steps "stepname|kindname".

Other options:
    --pretend             Only print out what files would be deleted; don't
                          actually delete anything
    --verbose             Print out the files that are being deleted
                          (automatically on if using --pretend)
    --deployment <testing|production> (default production)
                          Use your testing or production database

HELP
    exit;
}

if (! $desired_setup && ! @paths) {
    die <<ERROR;
vrpipe-rm: missing operand
Try `vrpipe-rm --help' for more information.
ERROR
}

VRPipe::Persistent::SchemaBase->database_deployment($deployment);
require VRPipe::Persistent::Schema;

my $m = VRPipe::Manager->get;
my $schema = $m->result_source->schema;

if ($desired_setup) {
    my $setup;
    if ($desired_setup =~ /^\d+$/) {
        $setup = $schema->resultset("PipelineSetup")->find({ id => $desired_setup });
        unless ($setup) {
            die "$desired_setup is not a valid pipeline setup id\n";
        }
    }
    else {
        $setup = $schema->resultset("PipelineSetup")->find({ name => $desired_setup });
        unless ($setup) {
            die "$desired_setup is not a valid pipeline setup name\n";
        }
    }
    
    # handle --steps
    my %desired_steps;
    foreach my $step_name (@steps) {
        my ($name, $kind) = split('\|', $step_name);
        $kind ||= 'all';
        if ($name =~ /^\d+$/) {
            $desired_steps{numbers}->{$name}->{$kind} = 1;
        }
        else {
            $desired_steps{names}->{$name}->{$kind} = 1;
        }
    }
    my @step_members = $setup->pipeline->steps;
    my @allowed_step_members;
    my %allowed_kinds;
    foreach my $stepm (@step_members) {
        my $smid = $stepm->id;
        my $step_name = $stepm->step->name;
        if (exists $desired_steps{names}->{$step_name}) {
            foreach my $kind (keys %{$desired_steps{names}->{$step_name}}) {
                $allowed_kinds{$smid}->{$kind} = 1;
            }
        }
        my $step_num = $stepm->step_number;
        if (exists $desired_steps{numbers}->{$step_num}) {
            foreach my $kind (keys %{$desired_steps{numbers}->{$step_num}}) {
                $allowed_kinds{$smid}->{$kind} = 1;
            }
        }
        next unless keys %{$allowed_kinds{$smid}};
        
        push(@allowed_step_members, $stepm);
    }
    
    # loop through completed elements
    my $pipeline_length = @step_members;
    my $elements = $setup->datasource->elements;
    my $deleted = 0;
    my $complete_elements = 0;
    my $incomplete = 0;
    foreach my $element (@$elements) {
        my $element_state = VRPipe::DataElementState->get(pipelinesetup => $setup, dataelement => $element);
        unless ($element_state->completed_steps == $pipeline_length) {
            $incomplete++;
            next;
        }
        $complete_elements++;
        
        # delete outputs
        foreach my $stepm (@allowed_step_members) {
            my $step_outs = VRPipe::StepState->get(stepmember => $stepm, dataelement => $element, pipelinesetup => $setup)->output_files;
            my $smid = $stepm->id;
            my $force = exists $allowed_kinds{$smid}->{all};
            
            while (my ($kind, $files) = each %$step_outs) {
                unless ($force) {
                    next unless exists $allowed_kinds{$smid}->{$kind};
                }
                my @files = grep { $_->s } @$files;
                next unless @files;
                
                my @file_data;
                foreach my $file (@files) {
                    if ($verbose) {
                        my $path = $file->path->stringify;
                        warn "$path\n";
                    }
                    $file->unlink unless $pretend;
                    $deleted++;
                }
            }
        }
    }
    
    warn "$incomplete incomplete data elements were ignored, and $deleted files ", ($pretend ? "would have been" : "were"), " deleted for $complete_elements complete elements\n" if $verbose;
}

my %protected_dirs;
my %dirs_with_files;
if (@paths) {
    if ($recurse && ! $force) {
        # find all protected directories ahead of time, since they complicate
        # things
        foreach my $path (@paths) {
            next unless -e $path;
            next unless -d $path;
            find({ wanted => \&protected_dir, no_chdir => 1 }, $path);
        }
    }
    
    foreach my $path (@paths) {
        if (-e $path || -l $path) {
            if (-d $path) {
                if ($recurse) {
                    finddepth({ wanted => \&rm_path, preprocess => \&skip_protected_dirs, no_chdir => 1 }, $path);
                }
                else {
                    warn "rm: cannot remove `$path': Is a directory\n";
                }
            }
            else {
                rm_path($path);
            }
        }
        elsif (! $force) {
            warn "rm: cannot remove `$path': No such file or directory\n";
        }
    }
}

sub protected_dir {
    my $path = $_;
    return if exists $protected_dirs{$path};
    foreach my $protected (keys %protected_dirs) {
        return if dir($protected)->subsumes($path);
    }
    
    if (-d $path && ! -w $path && ! dir_is_empty($path)) {
        print STDERR "rm: descend into write-protected directory `$path'? ";
        my $answer = <STDIN>;
        chomp($answer);
        unless ($answer =~ /^y(?:es)?$/) {
            $protected_dirs{$path} = 1;
        }
    }
}

sub dir_is_empty {
    my $dir = shift;
    my $dfh;
    if (opendir($dfh, $dir)) {
        readdir $dfh;
        readdir $dfh;
        if (readdir $dfh) {
            return 0;
        }
        else {
            return 1;
        }
    }
    return 1;
}

sub skip_protected_dirs {
    my @basenames;
    foreach my $basename (@_) {
        push(@basenames, $basename) unless exists $protected_dirs{dir($File::Find::dir, $basename)};
    }
    return @basenames;
}

sub rm_path {
    my $path = $_ || shift;
    if (-d $path) {
        return if exists $protected_dirs{$path};
        unless ($force) {
            return unless dir_is_empty($path);
        }
        unless (is_protected($path)) {
            rmdir($path);
        }
    }
    else {
        unless (is_protected($path)) {
            my $vrfile = $schema->resultset("File")->find({ path => file($path)->absolute });
            my $worked = 0;
            if ($vrfile) {
                $worked = $vrfile->unlink;
            }
            else {
                $worked = file($path)->remove;
            }
            
            unless ($worked) {
                warn "rm: cannot remove `$path': Permission denied\n";
            }
        }
    }
}

sub is_protected {
    my $path = shift;
    return 0 if $force;
    return 0 if -w $path;
    return 0 if -l $path;
    
    if (-d $path) {
        print STDERR "rm: remove write-protected directory `$path'? ";
    }
    else {
        if (-s $path) {
            print STDERR "rm: remove write-protected regular file `$path'? ";
        }
        else {
            print STDERR "rm: remove write-protected regular empty file `$path'? ";
        }
    }
    my $answer = <STDIN>;
    chomp($answer);
    if ($answer =~ /^y(?:es)?$/) {
        return 0;
    }
    
    return 1;
}

exit;